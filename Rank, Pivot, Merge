CREATE TABLE #ServiceSales (ServiceType VARCHAR(80), SalesYear INT, NoOfLeads int);
 
INSERT #ServiceSales VALUES 	('SQL SEVER TRAINING', 2014, 1200),
	('SQL SEVER TRAINING', 2015, 1900),('SQL SEVER TRAINING', 2016, 2300);
INSERT #ServiceSales VALUES	('SQL DBA TRAINING', 2014, 4000),
	('SQL DBA TRAINING', 2015, 5500), ('SQL DBA TRAINING', 2016, 5900);
INSERT #ServiceSales VALUES	('MSBI TRAINING', 2014, 900),
	('MSBI TRAINING', 2015, 1800),   ('MSBI TRAINING', 2016, 2300)
INSERT #ServiceSales VALUES	('POWER BI TRAINING',2016,150),('POWER BI TRAINING',2017,100);
INSERT #ServiceSales VALUES	('CASE STUDIES n PROJECTS', 2015, 1000),
	('CASE STUDIES n PROJECTS', 2016, 2800),('CASE STUDIES n PROJECTS', 2017, 4000);


SELECT * FROM #ServiceSales


-- HOW TO GENERATE ROW NUMBERS ?
SELECT * FROM #ServiceSales

SELECT *, 	ROW_NUMBER() OVER (ORDER BY ServiceType) AS RowNumberSequence,
			RANK() OVER (ORDER BY ServiceType) AS RankSequence,
			DENSE_RANK() OVER (ORDER BY ServiceType) AS DenseRankSequence,
			ROW_NUMBER() OVER (PARTITION BY ServiceType  ORDER BY ServiceType) AS PartitionSequence FROM #ServiceSales


/*
ROW_NUMBER		: Reports a unique value for each row.
RANK			: Reports same value for a repeated column. Next value depends on Row Number.
DENSE_RANK		: Reports same value for repeated column. Next value is sequence to previous Rank.
PARITION BY		: Reports repeated sequence for each value of the given column. 
*/


/*			PIVOT FUNCTIONS			*/

/*
PIVOT IS A MECHANISM TO CONVERT UNIQUE COLUMN VALUES INTO NEW COLUMNS. 
EX: 'SalesYear' COLUMN VALUES ARE : 2014, 2015, 2016, 2017. 
USING PIVOT, THESE COLUMN VALUES ARE CONVERTED INTO COLUMNS.

SYNTAX:	SELECT <COLUMNLIST> FROM <TABLE> OR <VIEW>
		PIVOT (<AGGREGATION ON PIVOT COLUMN>) 
		FOR <COLUMN WHOSE VALUES SHOULD BE NEW COLUMNS>  AS <CorrelationName> */

SELECT * FROM #ServiceSales

SELECT * FROM #ServiceSales 
PIVOT (Sum(NoOfLeads)
FOR SalesYear IN ([2014], [2015], [2016]))  AS PivotQuery	

-- This is called "Correlated Query"


SELECT * FROM #ServiceSales 
PIVOT (Sum(NoOfLeads)
FOR SalesYear IN ([2014], [2015], [2016], [2017]))  AS PivotQuery		-- This is called "Correlated Query"


/*
-- MERGE :		USED TO COMPARE TWO OR MORE TABLES AND PERFORM DML OPERATIONS
--				ONE DML OPERTATION ON MATCHING DATA. OTHER DML OPERATION ON MISSING DATA.

SYNTAX :	MERGE <TARGET TABLE>			-- THIS IS THE TABLE USED FOR ACTUAL DML OPERATIONS
			USING 
			<SOURCE TABLE>					-- THIS IS THE TABLE USED FOR COMPARISONS
			ON	<CONDITION>
			WHEN MATCHED THEN		......dml..........
			WHEN NOT MATCHED THEN	......dml..........	;
*/
USE tempdb
GO

CREATE TABLE tblOrders  
( 
ID INT NOT NULL PRIMARY KEY, 
TitleTag NVARCHAR(10) NOT NULL, 
Measure INT NOT NULL DEFAULT 0 
)

CREATE TABLE tblInventory  
( 
ID INT NOT NULL PRIMARY KEY, 
TitleTag NVARCHAR(100) NOT NULL, 
Measure INT NOT NULL DEFAULT 0 
)


INSERT tblOrders VALUES 		(1, 'Comedy', 100),  (2, 'NEGOT', 100), (3, 'BUSINESS', 100)

INSERT tblInventory VALUES  	(3, 'BUSN PROFILES', 200),  (4, 'PB CHAPTER', 200), 
								(5, 'BEG READER', 200),		(6, 'Literature', 200)

SELECT * FROM tblOrders; 
SELECT * FROM tblInventory;		-- 4 ROWS ONLY

-- 1 MATCHING ROW  ++ 2 MISSING ROWS

-- REQ: COMPARE ABOVE TWO TABLES. IDENTITY MATCHING DATA BASED ON ID. SUM THE MEASURE VALUES
-- FOR MISSING ROWS, INSERT THEM INTO INVENTORY TABLE.

MERGE tblInventory
USING tblOrders
ON
tblInventory.ID = tblOrders.ID
WHEN MATCHED THEN		UPDATE SET MEASURE = tblInventory.MEASURE  + tblOrders.MEASURE
WHEN NOT MATCHED THEN	INSERT VALUES (tblOrders.ID, tblOrders.TitleTag, tblOrders.MEASURE)
;


select * from tblInventory


-- HOW TO PERFORM DATA CLASSIFICATION OPERATIONS?
SELECT *, IIF(MEASURE = 100, 'GRADE 1', 'GRADE 2') AS GRADE FROM tblInventory

SELECT *, CASE  WHEN MEASURE = 100 THEN  'GRADE 1'
				WHEN MEASURE = 200 THEN  'GRADE 2'
				WHEN MEASURE = 300 THEN  'GRADE 3'
				ELSE 'GRADING NOT APPLICABLE'
		  END AS GRADE FROM tblInventory


-- HOW TO PERFORM PAGINATION WITH SQL QUERIES ?
-- USING "FETCH" AND "OFFSET" COMMANDS

-- HOW TO REPORT 3RD AND REMAINING ITEMS FROM THE LIST?
SELECT * FROM tblInventory ORDER BY ID OFFSET 2 ROWS  

-- HOW TO REPORT 3RD AND NEXT 3 ITEMS FROM THE LIST?
SELECT * FROM tblInventory ORDER BY ID OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY

-- HOW TO REPORT 3RD AND NEXT 2 ITEMS FROM THE LIST?
SELECT * FROM tblInventory ORDER BY ID OFFSET 2 ROWS FETCH NEXT 2 ROWS ONLY

-- TOP  on OFFSET  = FETCH


SELECT 
*, IIF(MEASURE = 100, 'row from orders', 'ROW from inventory') AS ROW_STATUS FROM tblInventory

SELECT *,  CASE		WHEN MEASURE = 100	THEN 'ROW FROM ORDERS'
					WHEN MEASURE = 200	THEN 'ROW FROM INVENTORY'
					WHEN MEASURE = 300	THEN 'ROW FROM ORDERS & INVENTORY' 
					ELSE  'NO GRADE AVAILABLE'
			END  AS ROW_STATUS FROM tblInventory
